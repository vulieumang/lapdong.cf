<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tu Ti√™n Pixel - Spritesheet</title>
    <style>
        :root {
            --bg: #070b18;
            --panel: #0f1933;
            --line: #24335f;
            --txt: #e7eeff;
            --muted: #91a4c7
        }

        body {
            margin: 0;
            background: radial-gradient(1000px 600px at 25% 20%, #14245c 0%, transparent 60%), var(--bg);
            color: var(--txt);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif
        }

        .wrap {
            max-width: 1100px;
            margin: 0 auto;
            padding: 14px
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 10px
        }

        h1 {
            margin: 0;
            font-size: 16px
        }

        .sub {
            color: var(--muted);
            font-size: 12px
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 12px
        }

        @media (max-width: 950px) {
            .grid {
                grid-template-columns: 1fr
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .02));
            border: 1px solid var(--line);
            border-radius: 16px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, .25)
        }

        .canvasWrap {
            padding: 10px
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, .08);
            background: #08102a;
            image-rendering: pixelated
        }

        .side {
            padding: 12px
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .pill {
            padding: 7px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(0, 0, 0, .22);
            color: var(--muted);
            font-size: 12px
        }

        .stat {
            margin-top: 10px;
            padding: 10px;
            border-radius: 14px;
            background: rgba(0, 0, 0, .18);
            border: 1px solid rgba(255, 255, 255, .08)
        }

        .stat .k {
            color: var(--muted);
            font-size: 12px
        }

        .stat .v {
            font-size: 16px;
            margin-top: 2px
        }

        button {
            cursor: pointer;
            border: none;
            border-radius: 12px;
            padding: 10px 12px;
            font-weight: 700;
            background: rgba(255, 255, 255, .06);
            color: var(--txt);
            border: 1px solid rgba(255, 255, 255, .10)
        }

        button:hover {
            background: rgba(255, 255, 255, .10)
        }

        .danger {
            border-color: rgba(255, 90, 90, .35);
            background: rgba(255, 90, 90, .12)
        }

        .hint {
            color: var(--muted);
            font-size: 12px;
            line-height: 1.35;
            margin-top: 10px
        }

        .log {
            margin-top: 10px;
            max-height: 260px;
            overflow: auto
        }

        .log p {
            margin: 0 0 8px;
            padding: 9px 10px;
            border-radius: 12px;
            background: rgba(0, 0, 0, .18);
            border: 1px solid rgba(255, 255, 255, .06);
            font-size: 12px
        }

        .bar {
            height: 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .08);
            overflow: hidden;
            margin-top: 6px
        }

        .bar>div {
            height: 100%;
            width: 0%
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <a href="index.html" style="text-decoration:none; margin-right: 15px; font-size: 24px;"
                title="Back to Home">üè°</a>
            <div>
                <h1>Tu Ti√™n Pixel (Spritesheet)</h1>
                <div class="sub">Ch·∫°y 4 h∆∞·ªõng (animation) ‚Ä¢ Ch√©m (J) ‚Ä¢ Slime nh√∫n nh·∫£y ‚Ä¢ Nh·∫∑t linh th·∫£o</div>
            </div>
            <div class="row">
                <div class="pill">WASD / ‚Üë‚Üì‚Üê‚Üí</div>
                <div class="pill">Shift: L∆∞·ªõt</div>
                <div class="pill">J: Ch√©m</div>
                <div class="pill">Save t·ª± ƒë·ªông</div>
            </div>
        </header>

        <div class="grid">
            <div class="card canvasWrap">
                <canvas id="game" width="960" height="540"></canvas>
            </div>

            <aside class="card side">
                <div class="row">
                    <button id="btnSave">L∆∞u</button>
                    <button id="btnReset" class="danger">Reset</button>
                </div>

                <div class="stat">
                    <div class="k">C·∫£nh gi·ªõi</div>
                    <div class="v" id="realm">Ph√†m Nh√¢n</div>
                    <div class="k" style="margin-top:8px">Tu vi</div>
                    <div class="v"><span id="xp">0</span> / <span id="xpNeed">50</span></div>
                    <div class="bar">
                        <div id="xpBar"></div>
                    </div>
                </div>

                <div class="stat">
                    <div class="k">Linh kh√≠</div>
                    <div class="v" id="lk">0</div>
                    <div class="k" style="margin-top:8px">M√°u</div>
                    <div class="v"><span id="hp">100</span> / 100</div>
                    <div class="bar">
                        <div id="hpBar"></div>
                    </div>
                </div>

                <div class="hint">
                    <b>Nh·∫∑t linh th·∫£o</b> (xanh) ƒë·ªÉ tƒÉng linh kh√≠ + tu vi. <b>Ch√©m slime</b> ƒë·ªÉ r∆°i linh kh√≠.
                    L√™n c·∫£nh gi·ªõi tƒÉng t·ªëc & s√°t th∆∞∆°ng.
                </div>

                <div class="log" id="log"></div>
            </aside>
        </div>
    </div>

    <script>
        (() => {
            const SAVE_KEY = "tutien_pixel_sheet_v1";

            const canvas = document.getElementById("game");
            const ctx = canvas.getContext("2d");

            const UI = {
                realm: document.getElementById("realm"),
                xp: document.getElementById("xp"),
                xpNeed: document.getElementById("xpNeed"),
                xpBar: document.getElementById("xpBar"),
                lk: document.getElementById("lk"),
                hp: document.getElementById("hp"),
                hpBar: document.getElementById("hpBar"),
                log: document.getElementById("log"),
            };

            // ===== Helpers =====
            const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
            const now = () => performance.now();
            const dist2 = (ax, ay, bx, by) => { const dx = ax - bx, dy = ay - by; return dx * dx + dy * dy; };
            function fmt(n) {
                if (!isFinite(n)) return "‚àû";
                if (Math.abs(n) < 1000) return Math.floor(n).toString();
                const u = ["K", "M", "B", "T"]; let i = -1; let x = n;
                while (Math.abs(x) >= 1000 && i < u.length - 1) { x /= 1000; i++ }
                return x.toFixed(2).replace(/\.00$/, "") + u[i];
            }
            function escapeHtml(s) {
                return String(s).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
                    .replaceAll('"', "&quot;").replaceAll("'", "&#039;");
            }

            // ===== Pixel spritesheet generator (PNG dataURL) =====
            // Player sheet: frameW=16, frameH=16
            // Rows = directions: 0 down, 1 left, 2 right, 3 up
            // Cols = walk frames: 0,1,2. Attack uses separate row block later.
            // We'll add attack row block: directions again, cols 0..1 (2 frames)
            function makePlayerSheet() {
                const fw = 16, fh = 16;
                const walkCols = 3, dirs = 4;
                const atkCols = 2;

                const w = fw * Math.max(walkCols, atkCols);
                const h = fh * (dirs + dirs); // 4 rows walk + 4 rows attack

                const c = document.createElement("canvas");
                c.width = w; c.height = h;
                const g = c.getContext("2d");
                g.imageSmoothingEnabled = false;

                function px(x, y, color) {
                    g.fillStyle = color; g.fillRect(x, y, 1, 1);
                }

                // draw a tiny "cultivator" base (robe + head + sword) per frame
                // frame offsets
                function drawCultivatorFrame(ox, oy, dir, step, isAttack) {
                    // clear frame
                    g.clearRect(ox, oy, fw, fh);

                    // subtle aura
                    g.fillStyle = "rgba(124,247,212,0.18)";
                    g.fillRect(ox + 4, oy + 4, 8, 8);

                    // step bounce
                    const bob = isAttack ? 0 : (step === 1 ? 0 : (step === 0 ? 1 : -1));
                    const y0 = oy + bob;

                    // robe color
                    const robe1 = "#a78bfa";
                    const robe2 = "#7c3aed";
                    const belt = "rgba(0,0,0,0.55)";
                    const skin = "#e8f1ff";
                    const hair = "#111827";
                    const sword = "#e5e7eb";
                    const glow = "rgba(124,247,212,0.75)";

                    // head
                    g.fillStyle = skin;
                    g.fillRect(ox + 6, y0 + 2, 4, 4);
                    // hair
                    g.fillStyle = hair;
                    g.fillRect(ox + 6, y0 + 2, 4, 1);

                    // robe body
                    g.fillStyle = robe1;
                    g.fillRect(ox + 5, y0 + 6, 6, 7);
                    g.fillStyle = robe2;
                    g.fillRect(ox + 5, y0 + 10, 6, 3);

                    // belt
                    g.fillStyle = belt;
                    g.fillRect(ox + 5, y0 + 9, 6, 1);

                    // feet (step)
                    g.fillStyle = "#1f2937";
                    if (!isAttack) {
                        if (step === 0) { g.fillRect(ox + 5, y0 + 13, 2, 1); g.fillRect(ox + 9, y0 + 12, 2, 1); }
                        if (step === 1) { g.fillRect(ox + 5, y0 + 12, 2, 1); g.fillRect(ox + 9, y0 + 12, 2, 1); }
                        if (step === 2) { g.fillRect(ox + 5, y0 + 12, 2, 1); g.fillRect(ox + 9, y0 + 13, 2, 1); }
                    } else {
                        g.fillRect(ox + 6, y0 + 13, 4, 1);
                    }

                    // sword direction + attack pose
                    g.fillStyle = sword;

                    // small sword positions
                    function drawSwordLine(x1, y1, x2, y2, col) {
                        g.strokeStyle = col;
                        g.lineWidth = 1;
                        g.beginPath();
                        g.moveTo(x1 + .5, y1 + .5);
                        g.lineTo(x2 + .5, y2 + .5);
                        g.stroke();
                    }

                    if (!isAttack) {
                        // idle/walk: sword on side based on dir
                        if (dir === 0) { // down
                            drawSwordLine(ox + 12, y0 + 8, ox + 14, y0 + 12, sword);
                            drawSwordLine(ox + 12, y0 + 8, ox + 14, y0 + 12, glow);
                        } else if (dir === 3) { // up
                            drawSwordLine(ox + 2, y0 + 8, ox + 4, y0 + 12, sword);
                            drawSwordLine(ox + 2, y0 + 8, ox + 4, y0 + 12, glow);
                        } else if (dir === 1) { // left
                            drawSwordLine(ox + 4, y0 + 7, ox + 1, y0 + 10, sword);
                            drawSwordLine(ox + 4, y0 + 7, ox + 1, y0 + 10, glow);
                        } else if (dir === 2) { // right
                            drawSwordLine(ox + 11, y0 + 7, ox + 14, y0 + 10, sword);
                            drawSwordLine(ox + 11, y0 + 7, ox + 14, y0 + 10, glow);
                        }
                    } else {
                        // attack: slash arc feel using 2 frames
                        // step acts as attack frame (0/1)
                        const f = step; // 0 or 1
                        if (dir === 2) { // right slash
                            if (f === 0) { drawSwordLine(ox + 10, y0 + 6, ox + 15, y0 + 3, sword); drawSwordLine(ox + 10, y0 + 6, ox + 15, y0 + 3, glow); }
                            else { drawSwordLine(ox + 10, y0 + 8, ox + 15, y0 + 12, sword); drawSwordLine(ox + 10, y0 + 8, ox + 15, y0 + 12, glow); }
                        } else if (dir === 1) { // left slash
                            if (f === 0) { drawSwordLine(ox + 6, y0 + 6, ox + 1, y0 + 3, sword); drawSwordLine(ox + 6, y0 + 6, ox + 1, y0 + 3, glow); }
                            else { drawSwordLine(ox + 6, y0 + 8, ox + 1, y0 + 12, sword); drawSwordLine(ox + 6, y0 + 8, ox + 1, y0 + 12, glow); }
                        } else if (dir === 0) { // down slash
                            if (f === 0) { drawSwordLine(ox + 8, y0 + 8, ox + 14, y0 + 10, sword); drawSwordLine(ox + 8, y0 + 8, ox + 14, y0 + 10, glow); }
                            else { drawSwordLine(ox + 8, y0 + 8, ox + 12, y0 + 14, sword); drawSwordLine(ox + 8, y0 + 8, ox + 12, y0 + 14, glow); }
                        } else if (dir === 3) { // up slash
                            if (f === 0) { drawSwordLine(ox + 8, y0 + 7, ox + 14, y0 + 5, sword); drawSwordLine(ox + 8, y0 + 7, ox + 14, y0 + 5, glow); }
                            else { drawSwordLine(ox + 8, y0 + 7, ox + 12, y0 + 1, sword); drawSwordLine(ox + 8, y0 + 7, ox + 12, y0 + 1, glow); }
                        }
                    }

                    // outline a bit (cheap)
                    g.strokeStyle = "rgba(0,0,0,0.35)";
                    g.strokeRect(ox + 4, y0 + 1, 8, 13);
                }

                // Walk rows
                for (let dir = 0; dir < dirs; dir++) {
                    for (let col = 0; col < walkCols; col++) {
                        const ox = col * fw;
                        const oy = dir * fh;
                        drawCultivatorFrame(ox, oy, dir, col, false);
                    }
                }
                // Attack rows start at y=dirs*fh
                for (let dir = 0; dir < dirs; dir++) {
                    for (let col = 0; col < atkCols; col++) {
                        const ox = col * fw;
                        const oy = (dirs + dir) * fh;
                        drawCultivatorFrame(ox, oy, dir, col, true);
                    }
                }

                return c.toDataURL("image/png");
            }

            // Slime sheet: fw=16, fh=16, cols=2, rows=1 (2 frame bounce)
            function makeSlimeSheet() {
                const fw = 16, fh = 16, cols = 2, rows = 1;
                const c = document.createElement("canvas");
                c.width = fw * cols; c.height = fh * rows;
                const g = c.getContext("2d"); g.imageSmoothingEnabled = false;

                function drawSlime(ox, oy, squish) {
                    g.clearRect(ox, oy, fw, fh);
                    const body = "rgba(255,107,107,0.92)";
                    const dark = "rgba(0,0,0,0.35)";
                    const hi = "rgba(255,255,255,0.35)";
                    const w = 12;
                    const h = squish ? 8 : 10;
                    const x = ox + 2;
                    const y = oy + (squish ? 6 : 4);

                    g.fillStyle = body; g.fillRect(x, y, w, h);
                    g.fillStyle = hi; g.fillRect(x + 2, y + 2, 3, 2);
                    g.fillStyle = dark; g.fillRect(x + 3, y + 4, 2, 2); // eyes
                    g.fillRect(x + 7, y + 4, 2, 2);
                    g.fillStyle = "rgba(255,255,255,0.7)";
                    g.fillRect(x + 2, y - 1, w - 4, 1); // top shine
                }

                drawSlime(0, 0, false);
                drawSlime(16, 0, true);

                return c.toDataURL("image/png");
            }

            const playerImg = new Image();
            const slimeImg = new Image();
            playerImg.src = makePlayerSheet();
            slimeImg.src = makeSlimeSheet();

            // ===== Game data =====
            const REALMS = [
                { name: "Ph√†m Nh√¢n", spd: 150, atk: 14 },
                { name: "Luy·ªán Kh√≠", spd: 165, atk: 18 },
                { name: "Tr√∫c C∆°", spd: 180, atk: 22 },
                { name: "Kim ƒêan", spd: 195, atk: 28 },
                { name: "Nguy√™n Anh", spd: 210, atk: 36 },
                { name: "H√≥a Th·∫ßn", spd: 225, atk: 46 },
            ];

            let state = defaultState();

            function defaultState() {
                return {
                    realmIndex: 0,
                    xp: 0,
                    lk: 0,
                    hp: 100,
                    px: canvas.width / 2,
                    py: canvas.height / 2,
                    dir: 0,          // 0 down,1 left,2 right,3 up
                    animT: 0,         // walk anim timer
                    attackT: 0,       // >0 means attacking
                };
            }

            // Mobs & Items
            let mobs = [];
            let herbs = [];
            let floats = []; // floating texts

            function spawnMobs(n) {
                for (let i = 0; i < n; i++) {
                    mobs.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        hp: 30,
                        maxHp: 30,
                        vx: (Math.random() - 0.5) * 50,
                        vy: (Math.random() - 0.5) * 50,
                        t: Math.random() * 10
                    });
                }
            }

            function spawnHerbs(n) {
                for (let i = 0; i < n; i++) {
                    herbs.push({
                        x: Math.random() * (canvas.width - 20) + 10,
                        y: Math.random() * (canvas.height - 20) + 10
                    });
                }
            }

            function addLog(msg) {
                const p = document.createElement("p");
                p.innerHTML = msg;
                UI.log.prepend(p);
                if (UI.log.children.length > 20) UI.log.lastChild.remove();
            }

            function addFloat(x, y, txt, col) {
                floats.push({ x, y, txt, col, life: 1.0 });
            }

            function checkLevelUp() {
                const realm = REALMS[state.realmIndex];
                // simple scaling xp
                const need = 50 * Math.pow(2, state.realmIndex);
                UI.xpNeed.innerText = fmt(need);
                if (state.xp >= need) {
                    if (state.realmIndex < REALMS.length - 1) {
                        state.realmIndex++;
                        state.xp -= need;
                        addLog(`‚ö° ƒê·ªôt ph√°! L√™n <b>${REALMS[state.realmIndex].name}</b>`);
                        // full heal
                        state.hp = 100;
                        checkLevelUp(); // recurse if overflow
                    } else {
                        state.xp = need; // cap
                    }
                }
                updateUI();
            }

            function updateUI() {
                const r = REALMS[state.realmIndex];
                UI.realm.innerText = r.name;
                UI.realm.style.color = state.realmIndex > 0 ? "#ffd700" : "#fff";
                UI.xp.innerText = fmt(state.xp);
                UI.lk.innerText = fmt(state.lk);
                UI.hp.innerText = Math.ceil(state.hp);

                const need = 50 * Math.pow(2, state.realmIndex);
                UI.xpNeed.innerText = fmt(need);
                UI.xpBar.parentNode.style.width = "100%";
                UI.xpBar.style.width = Math.min(100, (state.xp / need) * 100) + "%";
                UI.xpBar.style.background = "#3b82f6";
                UI.xpBar.style.height = "100%";

                UI.hpBar.style.width = Math.max(0, state.hp) + "%";
                UI.hpBar.style.background = state.hp < 30 ? "#ef4444" : "#22c55e";
                UI.hpBar.style.height = "100%";
            }

            // Input
            const keys = {};
            window.addEventListener("keydown", e => {
                keys[e.key.toLowerCase()] = true;
                if (e.key === "Shift") state.dash = true;
                if (e.key.toLowerCase() === "j") attack();
            });
            window.addEventListener("keyup", e => {
                keys[e.key.toLowerCase()] = false;
                if (e.key === "Shift") state.dash = false;
            });

            function attack() {
                if (state.attackT > 0) return;
                state.attackT = 0.3; // duration
                // Hitbox
                const r = REALMS[state.realmIndex];
                const reach = 40;
                let cx = state.px + 8, cy = state.py + 8;
                // direction offset
                if (state.dir === 0) cy += 20;
                else if (state.dir === 1) cx -= 20;
                else if (state.dir === 2) cx += 20;
                else if (state.dir === 3) cy -= 20;

                // check Mobs
                let hitAny = false;
                for (let i = mobs.length - 1; i >= 0; i--) {
                    const m = mobs[i];
                    if (dist2(cx, cy, m.x + 8, m.y + 8) < reach * reach) {
                        // hit
                        const dmg = r.atk * (1 + Math.random() * 0.5);
                        m.hp -= dmg;
                        addFloat(m.x, m.y, "-" + Math.floor(dmg), "#fff");
                        hitAny = true;
                        if (m.hp <= 0) {
                            // Mob die -> Drop LK
                            state.lk += 10 + 5 * state.realmIndex;
                            checkLevelUp();
                            mobs.splice(i, 1);
                            // respawn later
                            setTimeout(() => spawnMobs(1), 3000);
                        }
                    }
                }
                if (hitAny) {
                    // sfx?
                }
            }

            // Loop
            let lastT = now();
            function loop() {
                requestAnimationFrame(loop);
                const t = now();
                const dt = (t - lastT) / 1000;
                lastT = t;

                update(dt);
                draw();
            }

            function update(dt) {
                const r = REALMS[state.realmIndex];
                let speed = r.spd;
                if (state.dash && state.lk > 0) {
                    speed *= 2.0; // dash cost?
                    // state.lk -= dt * 5; // drain?
                }

                // Move
                let vx = 0, vy = 0;
                if (keys["w"] || keys["arrowup"]) vy = -1;
                if (keys["s"] || keys["arrowdown"]) vy = 1;
                if (keys["a"] || keys["arrowleft"]) vx = -1;
                if (keys["d"] || keys["arrowright"]) vx = 1;

                // Animation
                if (vx !== 0 || vy !== 0) {
                    // set dir
                    if (vy > 0) state.dir = 0;
                    if (vy < 0) state.dir = 3;
                    if (vx < 0) state.dir = 1;
                    if (vx > 0) state.dir = 2; // prioritize side?

                    // anim
                    state.animT += dt * 6; // frame rate

                    // normalize speed
                    if (vx !== 0 && vy !== 0) {
                        vx *= 0.707; vy *= 0.707;
                    }
                    state.px += vx * speed * dt;
                    state.py += vy * speed * dt;
                } else {
                    state.animT = 0; // idle
                }

                // Bounds
                state.px = clamp(state.px, 0, canvas.width - 16);
                state.py = clamp(state.py, 0, canvas.height - 16);

                // Attack cooldown
                if (state.attackT > 0) state.attackT -= dt;

                // Herbs
                for (let i = herbs.length - 1; i >= 0; i--) {
                    const h = herbs[i];
                    if (dist2(state.px + 8, state.py + 8, h.x + 4, h.y + 4) < 400) { // 20px radius
                        herbs.splice(i, 1);
                        const gain = 5 + state.realmIndex * 2;
                        state.xp += gain;
                        state.lk += gain;
                        addLog(`üåø Nh·∫∑t linh th·∫£o (+${gain})`);
                        addFloat(state.px, state.py, "+" + gain, "#4ade80");
                        checkLevelUp();
                        // respawn
                        setTimeout(() => spawnHerbs(1), 5000);
                    }
                }

                // Mobs AI
                mobs.forEach(m => {
                    m.t += dt;
                    m.x += m.vx * dt;
                    m.y += m.vy * dt;

                    // bounce bounds
                    if (m.x < 0 || m.x > canvas.width - 16) m.vx *= -1;
                    if (m.y < 0 || m.y > canvas.height - 16) m.vy *= -1;

                    // random change dir
                    if (Math.random() < 0.02) {
                        m.vx = (Math.random() - 0.5) * 50;
                        m.vy = (Math.random() - 0.5) * 50;
                    }

                    // collide with player -> Hurt
                    if (dist2(state.px + 8, state.py + 8, m.x + 8, m.y + 8) < 256) { // 16px touch
                        state.hp -= dt * 10; // dps
                        if (state.hp <= 0) {
                            state.hp = 0;
                            addLog("üíÄ B·∫°n ƒë√£ ng·∫•t! (H·ªìi ph·ª•c d·∫ßn...)");
                            // maybe dragging back to safe zone?
                        }
                    }
                });

                // Regen
                if (state.hp < 100) state.hp += dt * (1 + state.realmIndex);
                updateUI();

                // Floats
                for (let i = floats.length - 1; i >= 0; i--) {
                    floats[i].y -= dt * 20;
                    floats[i].life -= dt;
                    if (floats[i].life <= 0) floats.splice(i, 1);
                }
            }

            function draw() {
                // BG
                ctx.fillStyle = "#0f1933";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Grid lines?
                ctx.strokeStyle = "rgba(255,255,255,0.03)";
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 40) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
                for (let y = 0; y < canvas.height; y += 40) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
                ctx.stroke();

                // Herbs
                ctx.fillStyle = "#4ade80";
                herbs.forEach(h => {
                    ctx.beginPath();
                    ctx.arc(h.x, h.y, 3, 0, 7);
                    ctx.fill();
                    // glow
                    ctx.shadowColor = "#4ade80";
                    ctx.shadowBlur = 10;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                });

                // Mobs
                mobs.forEach(m => {
                    // wobble
                    const sq = Math.sin(m.t * 5) > 0;
                    // shadow
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillRect(m.x + 2, m.y + 12, 12, 4);
                    // sprite
                    // draw from slimeImg
                    // srcX = 0 or 16
                    const sx = sq ? 16 : 0;
                    ctx.drawImage(slimeImg, sx, 0, 16, 16, m.x, m.y, 16, 16);

                    // Hp bar
                    if (m.hp < m.maxHp) {
                        ctx.fillStyle = "red";
                        ctx.fillRect(m.x, m.y - 6, 16, 3);
                        ctx.fillStyle = "#0f0";
                        ctx.fillRect(m.x, m.y - 6, 16 * (m.hp / m.maxHp), 3);
                    }
                });

                // Player
                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fillRect(state.px + 4, state.py + 13, 8, 3);

                // Sprite
                // Determine source rect
                const fw = 16, fh = 16;
                // Dir: 0,1,2,3 -> row 0..3 (walk) OR 4..7 (attack)
                let row = state.dir;
                let col = 0;

                if (state.attackT > 0) {
                    row += 4; // Use attack rows
                    // Use attack time to determine frame 0 or 1
                    // Total duration 0.3.
                    // 0.3-0.15 -> frame 0. <0.15 -> frame 1
                    col = state.attackT > 0.15 ? 0 : 1;
                } else {
                    // Walk
                    // frame = 0, 1, 0, 2 pattern? loop 0,1,2
                    // simple 0,1,2
                    const f = Math.floor(state.animT) % 3;
                    col = f; // 0,1,2
                }

                ctx.drawImage(playerImg,
                    col * fw, row * fh, fw, fh,
                    state.px, state.py, fw, fh
                );

                // Floats
                ctx.font = "bold 12px sans-serif";
                floats.forEach(f => {
                    ctx.globalAlpha = f.life;
                    ctx.fillStyle = f.col;
                    ctx.fillText(f.txt, f.x, f.y);
                });
                ctx.globalAlpha = 1.0;
            }

            // Save/Load
            function save() {
                localStorage.setItem(SAVE_KEY, JSON.stringify(state));
                addLog("üíæ ƒê√£ l∆∞u game.");
            }
            function reset() {
                if (confirm("Reset to√†n b·ªô tu vi?")) {
                    localStorage.removeItem(SAVE_KEY);
                    location.reload();
                }
            }

            // Auto load
            const saved = localStorage.getItem(SAVE_KEY);
            if (saved) {
                try {
                    const s = JSON.parse(saved);
                    state = { ...defaultState(), ...s };
                    addLog("üìÇ ƒê√£ t·∫£i file save c≈©.");
                } catch (e) { console.error(e) }
            } else {
                spawnHerbs(16);
                spawnMobs(5);
                addLog("üë£ B·∫Øt ƒë·∫ßu! Nh·∫∑t linh th·∫£o, ch√©m slime ƒë·ªÉ tƒÉng tu vi.");
            }

            document.getElementById("btnSave").addEventListener("click", save);
            document.getElementById("btnReset").addEventListener("click", reset);

            // autosave silent
            setInterval(() => {
                try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch (_) { }
            }, 5000);

            // wait images ready (they are local dataURLs, but still async)
            Promise.all([
                new Promise(res => playerImg.complete ? res() : playerImg.onload = res),
                new Promise(res => slimeImg.complete ? res() : slimeImg.onload = res),
            ]).then(() => loop());
        })();
    </script>
</body>

</html>